# 第四部分：网络



## 1、你知道哪些http首部字段？

http协议是前端开发人员最常接触到的网络协议。在开发过程中，尤其是调试过程中避免不了需要去分析http请求的详细信息。在这其中头部字段提供的信息最多，比如通过响应状态码我们可以直观的看到响应的大致状态。那么你是否清楚http首部字段都有哪些，具体含义是什么，可选值又有哪些呢？看完下面的内容，我相信对于这几个问题你就会迎刃而解。

http协议用于交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的HTTP报文叫做响应报文。HTTP报文大致可以分为报文首部和报文主题两部分。我们来看下请求报文和响应报文的结构。
![img](https://img2018.cnblogs.com/blog/993712/201909/993712-20190903135632412-483353454.jpg)

从上图我们可以看出，请求报文和响应报文的首部内容由以下数据组成。

**请求行**

包含用于请求的方法，请求 URI 和 HTTP 版本。

**状态行**

包含表明响应结果的状态码，原因短语和 HTTP 版本。

**首部字段**

包含表示请求和响应的各种条件和属性的各类首部。

下面我们重点来看下首部字段的一些信息，并且对最常用到的首部字段的含义及可选值都有哪些，分别代表什么意思进行讲解。
**http首部字段类型根据实际用途被分为以下4种类型：**

通用首部字段（General Header Fields）

请求报文和响应报文两方都会使用的首部。

请求首部报文（Request Headers Fields）

从客户端向服务端发送请求报文时使用的首部。补充了请求的附加内容，客户端信息，响应内容相关优先级等信息。

响应首部字段（Response Header Fields）

从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

实体首部字段（Entity Header Fields）

针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体相关的信息。

------

其中http/1.1规范定义了47种首部字段，下面我们按照以上的四个大类对这47种字段进行一个简要解释：

通用首部字段

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存的行为             |
| Connection        | 连接的管理                 |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer-Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

请求首部字段

| 首部字段名          | 说明                                          |
| ------------------- | --------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                      |
| Accept-Charset      | 优先的字符集                                  |
| Accept-Encoding     | 优先的内容编码                                |
| Accept-Language     | 优先的语言（自然语言）                        |
| Authorization       | Web认证信息                                   |
| Expect              | 期待服务器的特定行为                          |
| From                | 用户的电子邮箱地址                            |
| Host                | 请求资源所在服务器                            |
| If-Match            | 比较实体标记（ETag）                          |
| If-Modified-Since   | 比较资源的更新时间                            |
| If-None-Match       | 比较实体标记（与 If-Match 相反）              |
| If-Range            | 资源未更新时发送实体 Byte 的范围请求          |
| If-Unmodified-Since | 比较资源的更新时间（与If-Modified-Since相反） |
| Max-Forwards        | 最大传输逐跳数                                |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                |
| Range               | 实体的字节范围请求                            |
| Referer             | 对请求中URI的原始获取方                       |
| TE                  | 传输编码的优先级                              |
| User-Agent          | HTTP客户端程序的信息                          |

响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过时间         |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定URI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| Retry-After        | 对再次发起请求的时机要求     |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

实体首部字段

| 首部字段名       | 说明                         |
| ---------------- | ---------------------------- |
| Allow            | 资源可支持的HTTP方法         |
| Content-Encoding | 实体主体适用的编码方式       |
| Content-Language | 实体主体的自然语言           |
| Content-Length   | 实体主体的大小（单位：字节） |
| Content-Location | 替代对应资源的URI            |
| Content-MD5      | 实体主体的报文摘要           |
| Content-Range    | 实体主体的位置范围           |
| Content-Type     | 实体主体的媒体类型           |
| Expires          | 实体主体过期的日期时间       |
| Last-Modified    | 资源的最后修改日期时间       |

## 2、说一下http缓存策略，有什么区别，分别解决了什么问题？

浏览器每次发起请求时，先在本地缓存中查找结果以及缓存标识，根据缓存标识来判断是否使用本地缓存。如果缓存有效，则使
用本地缓存；否则，则向服务器发起请求并携带缓存标识。根据是否需向服务器发起HTTP请求，将缓存过程划分为两个部分：
强制缓存和协商缓存，强缓优先于协商缓存。

- 强缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
- 协商缓存，让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的Etag和Last-Modified
  通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

HTTP缓存都是从第二次请求开始的：

- 第一次请求资源时，服务器返回资源，并在response header中回传资源的缓存策略；
- 第二次请求时，浏览器判断这些请求参数，击中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否击中协商缓存，击中则返回304，否则服务器会返回新的资源。这是缓存运作的一个整体流程图：

![img](https://img-blog.csdnimg.cn/20200712001807223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1ODM4MjA5NDkw,size_16,color_FFFFFF,t_70)

 

 

**2）强缓存**

- 强缓存命中则直接读取浏览器本地的资源，在network中显示的是from memory或者from disk
- 控制强制缓存的字段有：Cache-Control（http1.1）和Expires（http1.0）
- Cache-control是一个相对时间，用以表达自上次请求正确的资源之后的多少秒的时间段内缓存有效。
- Expires是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求
- Cache-Control的优先级比Expires的优先级高。前者的出现是为了解决Expires在浏览器时间被手动更改导致缓存判断错误的问题。
  如果同时存在则使用Cache-control。

**3）强缓存-expires**

- 该字段是服务器响应消息头字段，告诉浏览器在过期时间之前可以直接从浏览器缓存中存取数据。
- Expires 是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。在响应消息头中，设置这个字段之后，就可以告诉浏览器，在未过期之前不需要再次请求。
- 由于是绝对时间，用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效，重新请求该资源。此外，即使不考虑修改，时差或者误差等因素也可能造成客户端与服务端的时间不一致，致使缓存失效。
- 优势特点
  - 1、HTTP 1.0 产物，可以在HTTP 1.0和1.1中使用，简单易用。
  - 2、以时刻标识失效时间。
- 劣势问题
  - 1、时间是由服务器发送的(UTC)，如果服务器时间和客户端时间存在不一致，可能会出现问题。
  - 2、存在版本问题，到期之前的修改客户端是不可知的。

**4）强缓存-cache-control**

- 已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间，在该时间内，客户端不需要向服务器发送请求。

- 这两者的区别就是前者是绝对时间，而后者是相对时间。下面列举一些 `Cache-control` 字段常用的值：(完整的列表可以查看MDN)

  - `max-age`：即最大有效时间。
  - `must-revalidate`：如果超过了 `max-age` 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。
  - `no-cache`：不使用强缓存，需要与服务器验证缓存是否新鲜。
  - `no-store`: 真正意义上的“不要缓存”。所有内容都不走缓存，包括强制和对比。
  - `public`：所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)
  - `private`：所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。

- **Cache-control 的优先级高于 Expires**，为了兼容 HTTP/1.0 和 HTTP/1.1，实际项目中两个字段都可以设置。

- 该字段可以在请求头或者响应头设置，可组合使用多种指令：

  - 可缓存性

    ：

    - public：default，浏览器和缓存服务器都可以缓存页面信息
    - private：代理服务器不可缓存，只能被单个用户缓存
    - no-cache：浏览器器和服务器都不应该缓存页面信息，但仍可缓存，只是在缓存前需要向服务器确认资源是否被更改。可配合private，
      过期时间设置为过去时间。
    - only-if-cache：客户端只接受已缓存的响应

  - 到期

    - max-age=：缓存存储的最大周期，超过这个周期被认为过期。
    - s-maxage=：设置共享缓存，比如can。会覆盖max-age和expires。
    - max-stale[=]：客户端愿意接收一个已经过期的资源
    - min-fresh=：客户端希望在指定的时间内获取最新的响应
    - stale-while-revalidate=：客户端愿意接收陈旧的响应，并且在后台一部检查新的响应。时间代表客户端愿意接收陈旧响应
      的时间长度。
    - stale-if-error=：如新的检测失败，客户端则愿意接收陈旧的响应，时间代表等待时间。

  - 重新验证和重新加载

    - must-revalidate：如页面过期，则去服务器进行获取。
    - proxy-revalidate：用于共享缓存。
    - immutable：响应正文不随时间改变。

  - 其他

    - no-store：绝对禁止缓存
    - no-transform：不得对资源进行转换和转变。例如，不得对图像格式进行转换。

- 优势特点

  - 1、HTTP 1.1 产物，以时间间隔标识失效时间，解决了Expires服务器和客户端相对时间的问题。
  - 2、比Expires多了很多选项设置。

- 劣势问题

  - 1、存在版本问题，到期之前的修改客户端是不可知的。

**5）协商缓存**

- 协商缓存的状态码由服务器决策返回200或者304
- 当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。
- 对比缓存在请求数上和没有缓存是一致的，但如果是 304 的话，返回的仅仅是一个状态码而已，并没有实际的文件内容，因此 在响应体体积上的节省是它的优化点。
- 协商缓存有 2 组字段(不是两个)，控制协商缓存的字段有：Last-Modified/If-Modified-since（http1.0）和Etag/If-None-match（http1.1）
- Last-Modified/If-Modified-since表示的是服务器的资源最后一次修改的时间；Etag/If-None-match表示的是服务器资源的唯一标
  识，只要资源变化，Etag就会重新生成。
- Etag/If-None-match的优先级比Last-Modified/If-Modified-since高。

**6）协商缓存-协商缓存-Last-Modified/If-Modified-since**

- 1.服务器通过 `Last-Modified` 字段告知客户端，资源最后一次被修改的时间，例如 `Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT`
- 2.浏览器将这个值和内容一起记录在缓存数据库中。
- 3.下一次请求相同资源时时，浏览器从自己的缓存中找出“不确定是否过期的”缓存。因此在请求头中将上次的 `Last-Modified` 的值写入到请求头的 `If-Modified-Since` 字段
- 4.服务器会将 `If-Modified-Since` 的值与 `Last-Modified` 字段进行对比。如果相等，则表示未修改，响应 304；反之，则表示修改了，响应 200 状态码，并返回数据。
- 优势特点
  - 1、不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。
- 劣势问题
  - 2、只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。
  - 3、以时刻作为标识，无法识别一秒内进行多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。
  - 4、某些服务器不能精确的得到文件的最后修改时间。
  - 5、如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。

**7）协商缓存-Etag/If-None-match**

- 为了解决上述问题，出现了一组新的字段 `Etag` 和 `If-None-Match`
- `Etag` 存储的是文件的特殊标识(一般都是 hash 生成的)，服务器存储着文件的 `Etag` 字段。之后的流程和 `Last-Modified` 一致，只是 `Last-Modified` 字段和它所表示的更新时间改变成了 `Etag` 字段和它所表示的文件 hash，把 `If-Modified-Since` 变成了 `If-None-Match`。服务器同样进行比较，命中返回 304, 不命中返回新资源和 200。
- 浏览器在发起请求时，服务器返回在Response header中返回请求资源的唯一标识。在下一次请求时，会将上一次返回的Etag值赋值给If-No-Matched并添加在Request Header中。服务器将浏览器传来的if-no-matched跟自己的本地的资源的ETag做对比，如果匹配，则返回304通知浏览器读取本地缓存，否则返回200和更新后的资源。
- **Etag 的优先级高于 Last-Modified**。
- 优势特点
  - 1、可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。
  - 2、不存在版本问题，每次请求都回去服务器进行校验。
- 劣势问题
  - 1、计算ETag值需要性能损耗。
  - 2、分布式服务器存储的情况下，计算ETag的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现ETag不匹配的情况。

## 3、请描述TCP的三次握手和四次挥手

CP三次握手的过程如下:

建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发。

在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.

第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。

SYN：同步序列编号(Synchronize Sequence Numbers)

第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。

第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。



![img](https://pic2.zhimg.com/80/v2-08a83a15cf9060013484ffc688528829_720w.jpg)



为什么需要三次握手，是为了解决下列的一个问题:

client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用三次握手，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用三次握手的办法可以防止上述现象发生

四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发

TCP四次挥手的过程如下:



![img](https://pic2.zhimg.com/80/v2-3c3fdb98363aa7418b49cf8e0868af8d_720w.jpg)



1.第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。

2.第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。

3.第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。

4.第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1， Server进入CLOSED状态，完成四次挥手。

如果有大量的连接，每次在连接、关闭时都要三次握手，四次挥手，会很明显会造成性能低下，因此，

HTTP有一种叫做keep connection的机制，它可以在传输数据后仍然保持连接，当客户端再次获取数据时，直接使用刚刚空闲下的连接而无需再次握手



![img](https://pic2.zhimg.com/80/v2-249e9f2a599f1904cf0a604a71e4b501_720w.jpg)

## 4、tcp是什么

TCP即传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通讯协议。

TCP是为了在不可靠的互联网上提供可靠的端到端字节流而专门设计的一个传输协议。

互联网与单个网络有很大的不同，因为互联网的不同部分可能有截然不同的拓补结构、带宽、延迟、数据包大小和其他参数。TCP的设计目标是能够动态地适应互联网的这些特性，而且具备面向各种故障的健壮性。

不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。

应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受计算连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传输给IP层，有它来通过网络将包传送给接收端实体的TCP层。

TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后

接收端实体对已成功接收到的包回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未接收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来校验数据是否有误；在发送和接收时都要计算校验。

每台支持TCP的机器都有一个TCP传输实体。TCP 实体可以时一个库过程、一个用户进程、或者内核的一部分。在所有这些情形下，它管理TCP流，以及与IP层之间的接口。TCP传输实体接收本地进程的用户数据流，将他们分割成不超过64KB（实际上去掉IP和TCP头，通常不超过1460数据字节）的分段，每个分段以单独的IP数据报形式发送。当包含TCP数据的数据报到达一台机器时，它们被递交给TCP传输实体，TCP传输实体重构出原始的字节流。为简化起见，我们有时候仅仅用TCP来代表TCP传输实体（一段软件）或者TCP协议（一组规则）。根据上下文语义你应该能很清楚的推断出其实际含义。例如，在‘用户将数据提交给TCP’这句话中，很显然这里指的时TCP实体。

IP层并不保证数据报一定被正确的提交到接收方，也不只是数据报的发送速度有多块。正是TCP负责纪要足够快的发送数据报，以便使用网络容量，但又不能引起网络阻塞：而且，TCP超时后，要重传没有递交的数据报。即使被正确递交的数据报，也可能存在错误的问题，这也是TCP的责任，它必须把接收到的数据报重新装配成正确的顺序，简言之，TCP必须提供可靠性的良好性能，这正是大多数用户所期望的而IP又没有提供的功能。

**二、主要特点**

当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文。之后TCP把数据包传递给IP层，由它来通过网络将包传送给接收端实体的TCP层。

TCP是一种面向广域网的通信协议，目的是在跨越多个网络通信时，为两个通信端点之间提供一条具有一下特点的通信方式：

（1）基于流的方式；

（2）面向连接；

（3）可靠通信方式；

（4）在网络情况不佳的时候尽量降低系统由于重传带来的带宽开销；

（5）通信连接维护是面向的两个端点的，而不考虑中间网段和节点。

为满足TCP协议的这些特点，TCP协议做了以下规定：

①数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；

②到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认；

③超时重发：发送方在发送分片时启动超时定时器，如果在定时器超时之后没有接收到对应的确认，重发分片；

④滑动窗口：TCP连接每一方的接收缓冲空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出；

⑤失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对接收的数据进行重新排序，将接收到的数据以正确的顺序交给应用层；

⑥重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据；

⑦数据校验：TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到分片的校验和由差错，TCP将丢弃这个分片，并确认接收到此报文段导致对端超时并重发。

**三、工作方式**

建立连接

TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK，并最终对对方的SYN执行ACK确认。这种建立连接的方法可以防止产生错误的连接，TCP使用的流量控制协议是可便大小的华东窗口协议。

TCP三次握手的过程如下：

（1）客户端发送SYN（SEQ=x）报文给服务端，进入SYN_SEND状态。

（2）服务端接收SYN报文，回应一个SYN（SEQ=y）ACK（ACK=x+1）报文，进入SYN_RECV状态。

（3）客户端收到服务器端的SYN报文，回应一个ACK（ACK=y+1）报文，进入Established状态。

三次握手完成，TCP客户端和服务器端成功的建立连接，可以开始传输数据了。如图：

![img](https://img2018.cnblogs.com/blog/799221/201909/799221-20190904164958743-1252247495.png)

 

 

连接终止

建立一个连接需要三次握手，而重一一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。具体过程如下图所示。

![img](https://img2018.cnblogs.com/blog/799221/201909/799221-20190904165018172-1009077042.png)

 

 （1）某个应用进程首先调用close，称该端执行”主动关闭“（active close）。该端的TCP于是发送一个FIN分节，表示数据分发完毕。

（2）接收到这个FIN的对端执行”被动关闭“（passive close），这个FIN由TCP确认。

注意：FIN的接收也作为一个文件结束符（end-of-file）传递给接收端应用进程，放在已排队等候应用进程接收的任何其他数据报之后，因为，FIN的接收意味着金额手段应用进程相应连接再无额外数据可接收。

（3）一段时间后，接收到这个文件结束符的应用进程将调用close关闭它的套接字，这导致它的TCP也发送一个FIN。

（4）接收这个最终FIN的原发送端TCP（即执行主动关闭的那端）确认这个FIN。既然每个方向都需要一个FIN和一个ACK，因此通常需要4个分节。

## 5、HTTP2.0的特点 

1、增加二进制分帧

HTTP协议从0.9版本开始不断增加增加新的功能特性，但长远来看都是向前兼容的(现在的版本支持以后的版本数据)。HTTP 2.0在应用层跟传送层之间增加了一个二进制分帧层，从而能够达到在不改动HTTP的语义，HTTP方法，状态码，URI以及首部字段的情况下，突破HTTP 1.1的性能限制，改进传输性能，实现低延迟和高吞吐量

 ![img](https://img-blog.csdn.net/20180417150658295?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMzM3MTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) 

在上图所示，在二进制分帧层上，HTTP 2.0会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中HTTP 1.1的首部信息会被封装到Headers帧，而request body被封装到图中所示的DATA帧。相当于把部分数据塞进了二进制分帧层里，改进传输性能。

2、压缩头部

如下图所示： HTTP 2.0在客户端和服务端使用首部表来跟踪和存储之间发送的键-值对，对相同请求而言不需要再次发送请求和相应发送，通信期间几乎不会改变的通用键值,如user-Agent和content-Type值发送一次，相当于做了一层缓存。

- 如果请求不包含首部，如：对同一资源的轮询请求，那首部开销为零字节
- 如果首部发生变化，那只需发送变化的数据在Headers帧里面，新增或修改的首部帧会被追加到首部表

![img](https://img-blog.csdn.net/2018041715092012?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMzM3MTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3、多路复用

一个入了门的前端开发在谈到性能优化的方法时都可以轻轻松松列举如下几点
\- CSS雪碧图合并-减少请求
\- 合并压缩CSS跟JS代码-减少请求
\- CSS代码放在header头部里面，JS代码放到body结束之前，因为JS代码执行会阻塞
但HTTP 2.0的多路复用让我们回到最原始最自然的写码状态，先看下图

![img](https://img-blog.csdn.net/20180417151122849?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyMzM3MTA5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

对HTTP 1.1而言，浏览器通常有并行连接的限制，即最多几个并行链接。而多路复用允许通过单一的HTTP 2.0连接发起多重的请求-相应消息
这意味着HTTP 2.0的通信都在一个连接上完成了，这个连接可以承载任意数量的双向数据流，直观来说，就是上面我们所做的优化已经不需要了。

4、请求优先级

所有资源可以并行交错发送， 那想要优先拿到CSS和JS而不是图片怎么办，在每个HTTP 2.0的流里面有个优先值，这个优先值确定着客户端跟服务器处理不同的流采取不同的优先级策略，高优先级优先发送，但这不是绝对的(绝对等待会导致首队阻塞问题)

5、服务器提示

HTTP 2.0新增加服务器提示，可以先于客户端检测到将要请求的资源，提前通知客户端，服务器不发送所有资源的实体，只发送资源的URL，客户端接到提示后会进行验证缓存，如果真需要这些资源，则正式发起请求（服务器主动更新静态资源）

## 6、说一下HTTP2 多路复用原理，以及多路复用优势？

- **TCP慢启动：** TCP连接建立后，会经历一个先慢后快的发送过程，就像汽车启动一般，如果我们的网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗。另外慢启动是TCP为了减少网络拥塞的一种策略，我们是没有办法改变的。
- **多条TCP连接竞争带宽：** 如果同时建立多条TCP连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
- **HTTP/1.1队头阻塞：** 尽管HTTP/1.1长链接可以通过一个TCP连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。

为了解决以上几个问题，**HTTP/2一个域名只使用一个TCP⻓连接来传输数据，而且请求直接是并行的、非阻塞的，这就是多路复用**

**实现原理：** HTTP/2引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求ID的帧，这些帧在传输完成后根据ID组合成对应的数据。

## 7、简述https原理，以及与http的区别

一、HTTP和HTTPS的基本概念

HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。

HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

二**、**HTTP与HTTPS的区别
 　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
 　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
 　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
 　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

三**、**HTTP与HTTPS的工作原理

HTTP的工作原理：一次HTTP操作称为一个事物，其工作过程可分为四步

1、Client与Server建立连接，单击某个超链接，HTTP的工作开始。

2、连接建立后，Client发送一个请求给Server，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符，Client信息和可能的内容。

3、Server接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括Server信息、实体信息和可能的内容。

4、Client接收Server返回的信息通过浏览器显示在用户的显示屏上，然后Client和Server断开连接。

HTTPS的工作原理：

1、Client使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接。

2、Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。

3、客户端的浏览器与Web服务器开始协商SSL连接的安全等级，也就是信息加密的等级。

4、客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。

5、Web服务器利用自己的私钥解密出会话密钥。

6、Web服务器利用会话密钥加密与客户端之间的通信。

四**、**HTTPS的优缺点

优点：

1、使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；

2、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。

3、HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。

缺点：

1、HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；

2、HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；

3、SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。

4、SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。

5、HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。





## 8、CDN 是什么？描述下 CDN 原理？为什么要用 CDN?

用户体验优化一直是网站建设的核心所在。不管是网页外观设计，还是网站内容润色，都是围绕这一目标展开的。而除了这两点外，网站速度也是影响用户体验的重要因素之一。特别是对于那些第一次来访问网站的用户来说，如果网站速度很慢，他们可能就会直接放弃浏览，再优秀的网页设计也会失去用武之地。相反，如果网速很快，用户更有可能在网页上进行持续地浏览。当然，作为网站建设者，提高网站速度的方法有很多，比如代码优化、删除不必要的JS文件、对大图进行压缩或延迟加载等。不过这里天下数据小编要介绍一种新的方法：使用[CDN加速](https://www.idcbest.com/2017/Txsjcdn.asp)。其实这种方法也并不算新鲜，主要是很多站长对这种技术并不了解。什么是CDN加速？为什么要在网站中使用CDN加速？赶紧和小编一起来看看吧！

**什么是CDN加速？**

CDN（Content Delivery Network），即内容分发网络。它是指在现有互联网络中增加一层新的网络架构，其基本思路是尽可能避开互联网中可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输更快。换句话说，CDN加速可以实时根据网络流量和各节点的链接、负载状况以及用户距离和响应时间等信息将用户的请求重新导向到离用户最近的服务节点，降低网络的拥塞，提高内容传递的速度和效率，加快用户访问的响应速度。其实，CDN就像是网络中的"物流转运中心"，比如一个网站服务器在北京，用户人在广州，远距离使得用户访问体验不佳，而通过CDN，用户就可以从就近的深圳等地的网络节点获取数据信息。下图就是使用CDN和不使用CDN的一张对比图。

![什么是CDN加速？为什么要在网站中使用CDN加速？](https://www.idcbest.com/newsadmin/upFile/2019-9/20190918100715.png)

使用CDN和不使用CDN的对比

**为什么要在网站中应用CDN加速？**

**1. 网页加载速度更快**

在网站中使用CDN技术最直接的一个好处就是它可以加快网页的加载速度。首先，CDN加速的内容分发是基于服务器缓存的，由于CDN中缓存了不少数据，它能够给用户提供更快的页面响应速度。目前，CDN加速中可存储的文件形式很多，比如图片、模板、Javascript、视频、音频文件、网页字体以及其他形式的文件（HTML、PDF、PPT、ZIP等）。简单来说，任何可以存储在WP中的内容及文件夹都能存储在CDN中。其次，CDN加速善于优化数据传输路径。它可以收集节点与周围环境的信息，避免单一节点压力过高，保证每个节点的工作效率，优化用户访问路线，提高数据从源站到客户端的传输速度。最后，CDN加速不受运营商相互访问较慢的限制。比如某个企业的服务器是电信宽带，联通用户访问时速度一般较慢，而CDN的使用就可以有效避免这一情况，因为CDN几乎涵盖所有的线路，可以自动帮助用户选择最快的访问路径。

**2. 网站安全性&稳定性更高**

应用CDN技术还可以让网站更安全、更稳定。一方面，CDN中的负载均衡设备可以维持网站各个节点的平衡，避免单个节点压力太大，有效降低网络堵塞瘫痪的可能性。另一方面，即使某一个节点由于意外发生故障，用户对网站的访问也能自动导向到其他的健康节点上进行响应。所以说CDN不仅能有效缓解网络堵塞，还可以在某个服务器连接中断的情况下依旧保证网络信息的有效传递，这有助于维持网站的安全与稳定，帮助企业树立正面的品牌形象，提升用户对网站的好感。

**3. 服务器成本更低**

CDN加速是通过多地的不同节点完成数据传递的，用户的访问需求并不需要达到原始的服务器中，这个过程会比平时消耗更少的带宽。如果您是基于带宽支付主机托管费用的话，使用CDN加速可以有效降低服务器的成本。除了不必考虑服务器的更多投入外，您也不必考虑多台服务器的镜像同步或更多的管理维护技术人员，因为目前主流的CDN厂商都可以轻松实现网站的全国铺设。

**4. 网站SEO效果更好**

对于搜索引擎来说，它们更加倾向于加载速度快、稳定安全的网站。而CDN加速就可以轻松实现这两点，它既能通过服务器缓存、访问路径优化等技术加快网页的加载速度，还可以提供一定程度的安全保障，避免网站瘫痪状况的发生，减缓不知名的攻击。对了，您还可以将CDN加速和SSL证书结合起来建立更强的防御系统，让它对搜索引擎更加友好。

## 9、DNS 查询的过程，分为哪两种，是怎么一个过程



主要为bai两种：递归du查询 和迭代查询zhi
1.递归查询:
一般客户机和服dao务器之间zhuanshu递归查询，属即当客户机向DNS服务器发出请求后,若DNS服务器本身不能解析,则会向另外的DNS服务器发出查询请求，得到结果后转交给客户机；
2.迭代查询(反复查询):
一般DNS服务器之间属迭代查询，如：若DNS2不能响应DNS1的请求，则它会将DNS3的IP给DNS2，以便其再向DNS3发出请求。

## 10、强缓存和协商缓存的区别



**强制缓存**

`强制缓存`就是直接从浏览器缓存查找该结果，并根据结果的缓存规则来决定是否使用该缓存的过程。

- 不存在该缓存结果和标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）
- 存在缓存结果和标识，但结果已失效，强制缓存失效，则使用协商缓存
- 存在缓存结果和标识，并且结果未失效，强制缓存生效，直接返回该结果

控制强制缓存的字段分别是`Expires`和`Cache-Control`，其中`Cache-Control`优先级比`Expires`高。

**Expires**

`Expires`是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于`Expires`的值时，直接使用缓存结果。

**`Expires`是HTTP/1.0的字段，但现在浏览器默认使用HTTP/1.1，那么HTTP/1.1中网页缓存是否还是由`Expires`控制？**

到了HTTP/1.1，`Expires`已经被`Cache-Control`替代，原因在于`Expires`控制缓存的原理是使用客户端的时间和服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区）发送误差，那么强制缓存则会直接失效。

**Cache-Control**

在HTTP/1.1中，`Cache-Control`是最重要的规则，主要用于控制网页缓存，主要取值为：

- `public`：所有内容都将被缓存（客户端/代理服务器/CDN等）
- `private`：只有客户端可以缓存，`Cache-Control`默认值
- `no-cache`：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
- `no-store`：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
- `max-age=xxx`：缓存将在xxx秒后失效

>  `Cache-Control/Expires`同时存在时，只有`Cache-Control`生效
> ”

**协商缓存**

`协商缓存`就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，有服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

1. 协商缓存生效，返回304，服务器告诉浏览器资源未更新，则再去浏览器缓存中访问资 源
2. 协商缓存失效，返回200和请求结果

同样，协商缓存的标识也是在响应报文的HTTP头和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：

- `Last-Modified/If-Modified-Since`
- `Etag/If-None-Match`

其中`Etag/If-None-Match`优先级比`Last-Modified/If-Modified-Since`高

**Last-Modified/If-Modified-Since**

`Last-Modified`是服务器响应请求时，返回该资源文件在服务器最后被修改的时间。

`If-Modified-Since`则是客户端再次发起该请求时，携带上次请求返回的`Last-Modified`值，通过此字段告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有`If-Modified-Since`字段，则会根据`If-Modified-Since`的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后修改时间大于`If-Modified-Since`的字段值，则重新返回资源，状态码为200；否则返回304，代表资源无更新，可以继续使用缓存文件。

**Etag/If-None-Match**

`Etag`是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）。

`If-None-Match`是客户端再次发起请求时，携带上次请求返回的唯一标识Etag值，服务端收到该请求后，发现该请求含有`If-None-Match`，则会根据`If-None-Match`的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件，否则重新返回资源，状态码为200.

**总结**

`强制缓存`优先于`协商缓存`，若强制缓存生效则直接使用缓存，若不生效则进行协商缓存，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存。



## 11、为什么from表单提交没有跨域问题，但ajax有跨域问题

跨域限制的是从js里发起的请求，表单发起的请求并不需要js。

因为原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面中的内容。

所以浏览器认为这是安全的。

而 AJAX 是可以读取响应内容的，因此浏览器不能允许你这样做。

如果你细心的话你会发现，其实请求已经发送出去了，你只是拿不到响应而已。

所以浏览器这个策略的本质是，一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止你向另一个域名发送请求。





## 




