# 第十二部分：手写代码

## 1、手写一个Promise

```
/**
 * 自定义Promise函数模块
 */
(function () {

    const PENDING = 'pending'
    const RESOLVED = 'resolved'
    const REJECTED = 'rejected'


    /**
     * Promise构造函数
     * @param {*} executor 执行器函数
     */
    function Promise(executor) {
        const self = this
        // 给promise对象指定status属性，初始值为pending
        self.status = PENDING
        // 给promise对象指定一个用于存储结果数据的属性
        self.data = undefined
        // 每个元素的结构 { onResolved(){}, onRejected() }
        self.callbacks = []


        function resolve(value) {
            // 此处做判断，使得promise的状态只能修改一次
            if (self.status === PENDING) {
                // 将状态改为 resolved
                self.status = RESOLVED
                // 保存value数据
                self.data = value

                // 如果有待执行的callback函数，立即异步执行回调
                if (self.callbacks.length > 0) {
                    setTimeout(() => { // 表示在异步队列中执行
                        self.callbacks.forEach(callbacksObj => {
                            callbacksObj.onResolved(value)
                        })
                    }, 0);
                }
            }
        }
        function reject(reason) {
            // 此处做判断，使得promise的状态只能修改一次
            if (self.status === PENDING) {
                // 将状态改为 resolved
                self.status = REJECTED
                // 保存value数据
                self.data = reason

                // 如果有待执行的callback函数，立即异步执行回调
                if (self.callbacks.length > 0) {
                    setTimeout(() => { // 表示在异步队列中执行
                        self.callbacks.forEach(callbacksObj => {
                            callbacksObj.onRejected(reason)
                        })
                    }, 0);
                }
            }
        }

        // 立即执行器
        try {
            executor(resolve, reject);
        } catch (error) { // 如果执行器抛出异常，promise状态变为rejected状态
            reject(error)
        }
    }

    /**
     * Promise原型对象的then方法
     */
    Promise.prototype.then = function (onResolved, onRejected) {
        const self = this
        onResolved = typeof onResolved === 'function' ? onResolved : value => value
        // 指定默认的失败的回调（实现错误/异常穿透的关键点）
        onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason }


        return new Promise((resolve, reject) => {

            /**
             * 处理onResolve和onRejected函数
             * @param {*} callback 
             */
            function resolvePromise(callback) {
                try {
                    const result = callback(self.data)
                    if (result instanceof Promise) {
                        result.then(resolve, reject)
                    } else if (result !== null && (typeof result === 'object' || typeof result === 'function')) {
                        // 拿到result.then
                        const then = result.then;
                        if (typeof then === 'function') {
                            then(resolve, reject)
                        } else {
                            resolve(then)
                        }
                    } else {
                        resolve(result)
                    }
                } catch (error) {
                    reject(error)
                }
            }


            if (self.status === RESOLVED) {
                setTimeout(() => {
                    /**
                     * 1. 如果抛出异常，return 的 promise就会失败，reason就是error
                     * 2. 如果回调函数返回不是promise，return的promise就会成功，value就是返回值
                     * 3. 如果回调函数返回的是一个promise，return的promise的结果就是这个promise的结果，value就是返回值
                     */
                    resolvePromise(onResolved)
                }, 0);
            } else if (self.status === REJECTED) {
                setTimeout(() => {
                    resolvePromise(onRejected)
                }, 0);
            } else {
                self.callbacks.push({
                    onResolved(value) {
                        resolvePromise(onResolved)
                    },
                    onRejected(reason) {
                        resolvePromise(onRejected)
                    }
                })
            }
        })
    }

    /**
     * Promise原型对象的catch方法
     */
    Promise.prototype.catch = function (onRejected) {
        return this.then(undefined, onRejected)
    }

    /**
     * Promise函数对象的resolve方法
     * 
     * 返回一个指定结果的成功的promise
     */
    Promise.resolve = function (value) {
        return new Promise((resolve, reject) => {
            if (value instanceof Promise) {
                value.then(resolve, reject)
            } else {
                resolve(value)
            }
        })
    }

    /**
     * Promise函数对象的reject方法
     */
    Promise.reject = function (reason) {
        return new Promise((resolve, reject) => {
            reject(reason)
        })
    }

    /**
     * Promise函数对象的all方法
     */
    Promise.all = function (promises) {
        // 判断数组
        if (!(promises instanceof Array)) {
            return Promise.reject(new Error('params must be a Array!'))
        }
        // 用来保存所有数据成功value的数组
        const resultArray = new Array(promises.length)
        // 用来保存成功数量的计数
        let resultCount = 0
        return new Promise((resolve, reject) => {
            // 遍历获取每个promise的结果
            promises.forEach((p, index) => {
                Promise.resolve(p).then(value => {
                    resultCount++
                    resultArray[index] = value
                    // 如果全部都成功了，将return的promise变为成功
                    if (resultCount === promises.length) {
                        // 表示成功
                        resolve(resultArray)
                    }
                }, reason => {
                    reject(reason)
                })
            })
        })
    }

    /**
     * Promise函数对象的race方法
     */
    Promise.race = function (promises) {
        // 判断数组
        if (!(promises instanceof Array)) {
            return Promise.reject(new Error('params must be a Array!'))
        }

        return new Promise((resolve, reject) => {
            // 遍历数组
            promises.forEach((p, index) => {
                Promise.resolve(p).then(value => {
                    resolve(value)
                }, reason => {
                    reject(reason)
                })
            })
        })
    }

    // ---------------------------------------实现自己的方法---------------------------------------
    /**
     * 返回一个promise对象，它在指定的时间后才确定成功结果
     * @param {*} value 
     * @param {*} time 
     */
    Promise.resolveDelay = function (value, time) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if (value instanceof Promise) {
                    value.then(resolve, reject)
                } else {
                    resolve(value)
                }
            }, time);
        })
    }


    /**
     * 返回一个promise对象，它在指定的时间后才确定失败结果
     * @param {*} reason 
     * @param {*} time 
     */
    Promise.rejectDelay = function (reason, time) {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                reject(reason)
            }, time);
        })
    }



    // 向外暴露函数
    window.Promise = Promise
})(window)
```



## 2、手写call,apply,bind实现详解

```
call 接收多个参数，第一个为函数上下文也就是this，后边参数为函数本身的参数。

        let obj = {
            name: "一个"
        }
 
        function allName(firstName, lastName) {
            console.log(this)
            console.log(`我的全名是“${firstName}${this.name}${lastName}”`)
        }
        // 很明显此时allName函数是没有name属性的
        allName('我是', '前端') //我的全名是“我是前端”  this指向window
        allName.call(obj, '我是', '前端') //我的全名是“我是一个前端” this指向obj
复制代码
apply
apply接收两个参数，第一个参数为函数上下文this，第二个参数为函数参数只不过是通过一个数组的形式传入的。

allName.apply(obj, ['我是', '前端'])//我的全名是“我是一个前端” this指向obj
复制代码
bind
bind 接收多个参数，第一个是bind返回值返回值是一个函数上下文的this，不会立即执行。

        let obj = {
            name: "一个"
        }
 
        function allName(firstName, lastName, flag) {
            console.log(this)
            console.log(`我的全名是"${firstName}${this.name}${lastName}"我的座右铭是"${flag}"`)
        }
        allName.bind(obj) //不会执行
        let fn = allName.bind(obj)
        fn('我是', '前端', '好好学习天天向上')
 
        // 也可以这样用，参数可以分开传。bind后的函数参数默认排列在原函数参数后边
        fn = allName.bind(obj, "你是")
        fn('前端', '好好学习天天向上')
复制代码
接下来搓搓手实现call、apply和bind

实现call
      let Person = {
            name: 'Tom',
            say() {
                console.log(this)
                console.log(`我叫${this.name}`)
            }
        }
 
        // 先看代码执行效果
        Person.say() //我叫Tom 
        Person1 = {
            name: 'Tom1'
        }
 
        // 我们尝试用原生方法call来实现this指向Person1
        Person.say.call(Person1) //我叫Tom1
 
复制代码
通过第一次打印执行和第二次打印执行我发现，如果Person1有say方法那么Person1直接执行Person1.say() 结果就是我是Tom1,是的call就是这么实现的。 再看代码

        Function.prototype.MyCall = function(context) {
            //context就是demo中的Person1
            // 必须此时调用MyCall的函数是say方法，那么我们只需要在context上扩展一个say方法指向调用MyCall的say方法这样this
            console.log(this)
            context.say = this //Mycall里边的this就是我们虚拟的say方法
            context.say()
        }
        // 测试
        Person.say.MyCall(Person1)//我叫Tom1
复制代码
 perfect！爆棚的满足感！不过拿脚趾头想想也不会这么简单，继续完善 我们自己找茬 1、call支持多个参数，有可能一个也不没有 2、考虑多参数时要把参数传给扩展方法。 3、给上下文定义的函数要保持唯一不能是say 4、扩展完我们需要吧自定义函数删除 接下来针对找茬问题一一解决
        let Person = {
            name: 'Tom',
            say() {
                console.log(this)
                console.log(`我叫${this.name}`)
            }
        }
        Person1 = {
            name: 'Tom1'
        }
        //如果没有参数
        Person.say.call()
复制代码
没有指定this，this指向window
我们也要这样

        Function.prototype.MyCall = function(context) {
            // 如果没有参数我们参考call的处理方式
            context = context || window
                //context就是demo中的Person1
                // 必须此时调用MyCall的函数是say方法，那么我们只需要在context上扩展一个say方法指向调用MyCall的say方法这样this
            context.say = this //Mycall里边的this就是我们虚拟的say方法
            context.say()
        }
 
        Person.say.MyCall()
复制代码
 没毛病！ 继续解决
// 找茬2：我们默认定义context.say = this  fn如果已经被占用 嘎嘎 sb了。 不怕 搞定它
 
        // say需要是一个唯一值 是不是突然想到es6的新类型 Symbol   fn = Symbol() 不过我们装逼不嫌事大 都说自己实现了
 
        function mySymbol(obj) {
            // 不要问我为什么这么写，我也不知道就感觉这样nb
            let unique = (Math.random() + new Date().getTime()).toString(32).slice(0, 8)
                // 牛逼也要严谨
            if (obj.hasOwnProperty(unique)) {
                return mySymbol(obj) //递归调用
            } else {
                return unique
            }
        }
//接下来我们一并把多参数和执行完删除自定义方法删除掉一块搞定
        Function.prototype.myCall1 = function(context) {
            // 如果没有传或传的值为空对象 context指向window
            context = context || window
            let fn = mySymbol(context)
            context.fn = this //给context添加一个方法 指向this
            // 处理参数 去除第一个参数this 其它传入fn函数
            let arg = [...arguments].slice(1) //[...xxx]把类数组变成数组，arguments为啥不是数组自行搜索 slice返回一个新数组
            context.fn(...arg) //执行fn
            delete context.fn //删除方法
        }
        
        let Person = {
            name: 'Tom',
            say(age) {
                console.log(this)
                console.log(`我叫${this.name}我今年${age}`)
            }
        }
 
        Person1 = {
            name: 'Tom1'
        }
 
        Person.say.call(Person1,18)//我叫Tom1我今年18
复制代码
测试结果相当完美！

实现apply
接下来apply就简单多了，只有多参数时第二个参数是数组，就不一步步细说了。

        Function.prototype.myApply = function(context) {
            // 如果没有传或传的值为空对象 context指向window
            if (typeof context === "undefined" || context === null) {
                context = window
            }
            let fn = mySymbol(context)
            context.fn = this //给context添加一个方法 指向this
                // 处理参数 去除第一个参数this 其它传入fn函数
            let arg = [...arguments].slice(1) //[...xxx]把类数组变成数组，arguments为啥不是数组自行搜索 slice返回一个新数组
            context.fn(arg) //执行fn
            delete context.fn //删除方法
 
        }
复制代码
实现bind
这个和call、apply区别还是很大的，容我去抽根烟回来收拾它 还是老套路先分析bind都能干些什么，有什么特点 1、函数调用，改变this 2、返回一个绑定this的函数 3、接收多个参数 4、支持柯里化形式传参 fn(1)(2)

       Function.prototype.bind = function(context) {
            //返回一个绑定this的函数，我们需要在此保存this
            let self = this
                // 可以支持柯里化传参，保存参数
            let arg = [...arguments].slice(1)
                // 返回一个函数
            return function() {
                //同样因为支持柯里化形式传参我们需要再次获取存储参数
                let newArg = [...arguments]
                console.log(newArg)
                    // 返回函数绑定this，传入两次保存的参数
                    //考虑返回函数有返回值做了return
                return self.apply(context, arg.concat(newArg))
            }
        }
 
        // 搞定测试
        let fn = Person.say.bind(Person1)
        fn()
        fn(18)
复制代码

```



## 3、手写一个instanceOf

```
实现思路：
首先 instanceof 左侧必须是对象, 才能找到它的原型链

instanceof 右侧必须是函数, 函数才会prototype属性

迭代 , 左侧对象的原型不等于右侧的 prototype时, 沿着原型链重新赋值左侧

 

复制代码
// [1,2,3] instanceof Array ---- true

// L instanceof R
// 变量R的原型 存在于 变量L的原型链上
function instance_of(L,R){    
    // 验证如果为基本数据类型，就直接返回false
    const baseType = ['string', 'number','boolean','undefined','symbol']
    if(baseType.includes(typeof(L))) { return false }
    
    let RP  = R.prototype;  //取 R 的显示原型
    L = L.__proto__;       //取 L 的隐式原型
    while(true){           // 无线循环的写法（也可以使 for(;;) ）
        if(L === null){    //找到最顶层
            return false;
        }
        if(L === RP){       //严格相等
            return true;
        }
        L = L.__proto__;  //没找到继续向上一层原型链查找
    }
}
```



## 4、手写一个防抖的实现

```
!DOCTYPE html>
 
<html>
<!-- 防抖 -->
<!-- 防抖就是在n秒内 防止连续触发，在n秒内触发了下一次，那就重新计算 -->
 
<body>
  <div id="content"
    style="height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"></div>
  <script>
    let num = 1;
    let content = document.getElementById('content');
    /**
     *非立即执行版
     **/
    function debounceNoAtOnce(func, wait) {
      let timeout;
      return function () {
        let context = this;
        let args = arguments;
        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(() => {
          func.apply(context, args)
        }, wait);
      }
    };
 
    /**
     *立即执行版
     **/
    function debounceAtOnce(func, wait) {
      let timeout;
      return function () {
        let context = this;
        let args = arguments;
        debugger
        if (timeout) clearTimeout(timeout);
 
        let callNow = !timeout;
        timeout = setTimeout(() => {
          timeout = null;
        }, wait)
 
        if (callNow) func.apply(context, args)
      }
    }
    /**
     *聚合版
     **/
    function debounce(func, wait, immediate) {
      let timeout;
 
      return function () {
        let context = this;
        let args = arguments;
 
        if (timeout) clearTimeout(timeout);
        if (immediate) {
          var callNow = !timeout;
          timeout = setTimeout(() => {
            timeout = null;
          }, wait)
          if (callNow) func.apply(context, args)
        } else {
          timeout = setTimeout(function () {
            func.apply(context, args)
          }, wait);
        }
      }
    }
 
    function count() {
      content.innerHTML = num++;
    };
    content.onmousemove = debounce(count, 1000, true);
  </script>
</body>
<script>
</script>
 
</html>
防抖的目的在于：n秒内点击多少次都算一次+每次点击都重新计算时间

```



## 5、手写一个节流的实现  

```

<!DOCTYPE html>
 
<html>
<!-- 节流 -->
<!-- 节流是为了固定的时间段内只能点击一次 -->
 
<body>
  <div id="content"
    style="height:150px;line-height:150px;text-align:center; color: #fff;background-color:#ccc;font-size:80px;"></div>
  <script>
    let num = 1;
    let content = document.getElementById('content');
    /**
     *throttleTime 时间戳版
     **/
    throttleTime = function (func, wait) {
      let previde = 0;
      return function () {
        let nowDate = Date.now();
        if (nowDate - previde > wait) {
          func();
          previde = nowDate;
        }
      }
    }
    /**
     *throttleSet 定时器版
     **/
    throttleSet = function (func, wait) {
      let timeout;
      return function () {
        if (!timeout) {
          timeout = setTimeout(() => {
            timeout = false
            func()
          }, wait)
        }
      }
    }
 
    function count() {
      content.innerHTML = num++;
    };
    content.onmousemove = throttleSet(count, 1000);
  </script>
</body>
<script>
</script>
 
</html>
```

节流的目的在于：固定时间段内只能点击一次

应用场景：输入框输入+提交/确定

## 6、手写ajax

```
function createXMLHTTPRequest() {     
                 //1.创建XMLHttpRequest对象     
                 //这是XMLHttpReuquest对象无部使用中最复杂的一步     
                 //需要针对IE和其他类型的浏览器建立这个对象的不同方式写不同的代码     
                 var xmlHttpRequest;  
                 if (window.XMLHttpRequest) {     
                     //针对FireFox，Mozillar，Opera，Safari，IE7，IE8     
                    xmlHttpRequest = new XMLHttpRequest();     
                     //针对某些特定版本的mozillar浏览器的BUG进行修正     
                     if (xmlHttpRequest.overrideMimeType) {     
                         xmlHttpRequest.overrideMimeType("text/xml");     
                     }     
                 } else if (window.ActiveXObject) {     
                     //针对IE6，IE5.5，IE5     
                     //两个可以用于创建XMLHTTPRequest对象的控件名称，保存在一个js的数组中     
                     //排在前面的版本较新     
                     var activexName = [ "MSXML2.XMLHTTP", "Microsoft.XMLHTTP" ];     
                     for ( var i = 0; i < activexName.length; i++) {     
                         try {     
                             //取出一个控件名进行创建，如果创建成功就终止循环     
                             //如果创建失败，回抛出异常，然后可以继续循环，继续尝试创建     
                            xmlHttpRequest = new ActiveXObject(activexName[i]);   
                            if(xmlHttpRequest){  
                                break;  
                            }  
                         } catch (e) {     
                         }     
                     }     
                 }     
                 return xmlHttpRequest;  
             }     
```



## 7、手写JSONP的原理和实现

JSONP实现原理

jsonp，其实就是单纯为了实现跨域请求而创造的一个欺骗(trick)。

虽然，因为同源策略的影响，不能通过XMLHttpRequest请求不同域上的数据(Cross -origin reads)。但是，在页面上引入不同域上的js脚本文件却是可以的(Cross -origin embedding)。因此，在js文件载入完毕之后，触发回调，可以将需要的data作为参数传入
注意，实现方式(需前后端配合)

 

优点

兼容性好(兼容低版本IE)

缺点

JSONP只支持GET请求，XMLHttpRequest相对于JSONP有着更好的错误处理机制。

 

实现

1.服务端采用的是Node，服务端处理请求方法如下

```javascript
router.get('/', function(req, res, next) {



    console.log('收到客户端的请求：', req.query);



    // 传回到客户端的数据



    let data = JSON.stringify({



        'status':200,



        'result':{



            'name':'柳成荫',



            'site':'123456'



        }



    });



    // 获取方法名称 - 这是客户端传过来的方法名参数



    // 因为这个方法名必须是客户端有的，必须要客户端告诉服务端是哪个方法



    let methodName = req.query.callback;



    let methodStr = methodName + '(' + data + ')';



    // 快速结束没有任何数据的响应，客户端会执行这个方法，从而获取到服务端返回的数据



    res.end(methodStr)



});
```

2.封装JSONP

```javascript
(function (w) {



        /**



         * jsonp的实现



         * @param {Object}option



         */



        function jsonp(option) {



            // 把success函数挂载在全局的getDate函数上



            w.getData = option.success;



            // 处理url,拼接参数 - 回调方法是getData



            option.url = option.url + '?callback=getData';



            // 创建script标签，并插入body



            let scriptEle = document.createElement('script');



            scriptEle.src = option.url;



            document.body.appendChild(scriptEle);



        }



        // 全局挂载一个jsonp函数



        w.jsonp = jsonp;



    })(window);



 



    /**



     * 把对象转换成拼接字符串



     * 把形如



       data:{



          "sex":"男",



          "name":"九月"



        }



       转换成sex=男&name=九月



     * @param paramObj 对象参数



     * @param words



     * @returns {string} 字符串



     */



    function getStrWithObject(paramObj,words){



        let resArr = [];



        // 1.转换对象



        for(let key in paramObj){



            let str = key + '=' + paramObj[key];



            resArr.push(str);



        }



        resArr.push(words);



        // 3.数组转换成字符串



        return resArr.join("&");



    }
```

看似代码没有任何问题。但是，我们测试一下，多次调用jsonp方法。

```javascript
jsonp({



        url:'http://localhost:3000/',



        data:{



            "sex":"男",



            "name":"九月"



        },



        success:function (data) {



            console.log(data);



            alert(1);



        }



    });



 



    jsonp({



        url:'http://localhost:3000/',



        data:{



            "sex":"男",



            "name":"九月"



        },



        success:function (data) {



            console.log(data);



            alert(2);



        }



    });
```

结果会怎么样？的确，还是会执行2次，但是每次执行的都是第二个jsonp方法。这是为什么？

问题出现在这里，多次调用，会发生函数覆盖。

![img](https://img-blog.csdnimg.cn/20191218213657460.png)

解决方案就是让每一次调用函数名不一致，在JS里有很多方法，比如通过随机数、时间戳之类的。这里采用的是随机数，修改如下。

```javascript
// 0.产生不同的函数名 - 解决了调用多次请求，造成覆盖的问题



// 如果方法名相同，调用多次，都会执行最后一个，出现覆盖现象



let callBackName = 'lcy' + Math.random().toString().substr(2) 



+ Math.random().toString().substr(2);



// 把success函数挂载在全局的getDate函数上



w[callBackName] = option.success;



// 处理url,拼接参数



option.url = option.url + '?' + getStrWithObject(option.data,'callback='+callBackName);
```

 好，现在看似完美解决。然而，我们发现，每次调用jsonp方法，都会在body里插入一个script标签。我们并不希望在调用jsonp之后，添加这样一个标签，我们需要在调用完之后，将其移除。

怎么做呢？我们在将success函数挂载在全局时，我们在success外层再套个函数。在这个函数里调用success方法之后，即已经请求到数据之后，我们就去把这个script标签给它移除就行了。修改如下

```javascript
// 1.函数挂载在全局



w[callBackName] = function(data){



    option.success(data);



    // 删除script标签



    document.body.removeChild(scriptEle);



};
```

整个过程就是这样，以下是完整代码。

```javascript
 (function (w) {



        /**



         * jsonp的实现



         * @param {Object}option



         */



        function jsonp(option) {



            // 0.产生不同的函数名 - 解决了调用多次请求，造成覆盖的问题



            // 如果方法名相同，调用多次，都会执行最后一个，出现覆盖现象



            let callBackName = 'lcy' + Math.random().toString().substr(2) + Math.random().toString().substr(2);



            // 1.函数挂载在全局



            w[callBackName] = function(data){



                option.success(data);



                // 删除script标签



                document.body.removeChild(scriptEle);



            };



            // 2.处理url



            option.url = option.url + '?' + getStrWithObject(option.data,'callback='+callBackName);



            // 3.创建script标签插入body



            let scriptEle = document.createElement('script');



            scriptEle.src = option.url;



            document.body.appendChild(scriptEle);



        }



        w.jsonp = jsonp;



    })(window);



 



    /**



     * 把对象转换成拼接字符串



     * @param paramObj 对象参数



     * @returns {string} 字符串



     */



    function getStrWithObject(paramObj,words){



        let resArr = [];



        // 1.转换对象



        for(let key in paramObj){



            let str = key + '=' + paramObj[key];



            resArr.push(str);



        }



        resArr.push(words);



        // 3.数组转换成字符串



        return resArr.join("&");



    }
```

## 8、手写深拷贝



```
ar a = {
    name: "muyiy",
    book: {
        title: "You Don't Know JS",
        price: "45"
    },
    a1: undefined,
    a2: null,
    a3: 123
}
// hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链。
function cloneDeep1(source) {
    var target = {};
    for (var key in source) {
        if (source.hasOwnProperty(key)) {
            if (typeof source[key] === 'object') {
                target[key] = cloneDeep1(source[key]); // 注意这里
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}

// 使用上面测试用例测试一下
console.log(a)
var b = cloneDeep1(a);
a.name = "前端进阶";
a.book.price = "55";
console.log(b);

考虑再全一些的深拷贝


function deepClone(obj,hash = new WeakMap()){ //递归实现
    if(obj instanceof RegExp) return new RegExp(obj);
    if(obj instanceof Date) return new Date(obj);
    if(obj === null || typeof obj != "object"){
        // 普通数据类型
        return obj;
    }
    if(hash.has(obj)){
        return hash.get(obj);
    }
    // 下面是数组和对象的判断
    let t = new obj.constructor();
    hash.set(obj,t);
    for(let key in obj){
        //  递归
        if(obj.hasOwnProperty(key)){ //是否是自身的属性
            t[key] = deepClone(obj[key],hash)
        }
    }
    return t;
}
```



## 9、bind



```
function print() {
    console.log(this.name, ...arguments);
}

const obj = {
    name: 'mxin',
};

// Function.prototype.__bind()
console.log('Function.prototype.__bind()');

// 直接调用，返回原函数拷贝，this 指向 obj
const F = print.__bind(obj, 26);
F(178); // mxin, 26, 178

// new 情况
const _obj = new F(145); // undefined, 26, 145
console.log(_obj); // print {}

// Function.prototype.bind()
console.log('Function.prototype.bind()');

const Fn = print.bind(obj, 26);
Fn(178); // mxin, 26, 178

const __obj = new Fn(145); // undefined, 26, 145
console.log(__obj); // print {}
```





## 10 call



```
/**
 * 模拟 call
 * 使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数
 * @param {object} ctx
 * @param  {...any} args
 * @returns {any} 调用 this 的返回值，若无有返回值，则返回 undefined
 */
Function.prototype.__call = function (ctx, ...args) {
    if (typeof this !== 'function') throw new TypeError('Error');

    // 考虑 null 情况，参数默认赋值会无效
    if (!ctx) ctx = window;

    // 将 this 函数保存在 ctx 上
    ctx.fn = this;

    // 传参执行并保存返回值
    const res = ctx.fn(...args);

    // 删除 ctx 上的 fn
    delete ctx.fn;
  
    return res;
};

// ------------------------------ 测试 ------------------------------

function Product(name, price) {
    this.name = name;
    this.price = price;
}

// Function.prototype.__call()
console.log('Function.prototype.__call()');

function Food(name, price) {
    Product.__call(this, name, price);
    this.category = 'food';
}
const food = new Food('cheese', 5);
console.log(food);
// Food {name: "cheese", price: 5, category: "food"}
//   category: "food"
//   name: "cheese"
//   price: 5
//   __proto__:
//     constructor: ƒ Food(name, price)
//     __proto__: Object

// Function.prototype.call()
console.log('Function.prototype.call()');

function Toy(name, price) {
    Product.call(this, name, price);
    this.category = 'toy';
}
const toy = new Toy('car', 10);
console.log(toy);
// Toy {name: "car", price: 10, category: "toy"}
//   category: "toy"
//   name: "car"
//   price: 10
//   __proto__:
//     constructor: ƒ Toy(name, price)
//     __proto__: Object
```





## 11 apply



```

/**
 * 模拟 apply
 * 调用一个具有给定 this 值的函数，以及以一个数组（或类数组对象）的形式提供的参数
 * @param {object} ctx
 * @param {} args
 */
Function.prototype.__apply = function (ctx, args) {
    if (typeof this !== 'function') throw new TypeError('Error');

    // 考虑 null 情况，参数默认赋值会无效
    if (!ctx) ctx = window;

    // 将 this 函数保存在 ctx 上
    ctx.fn = this;

    // 传参执行并保存返回值
    const result = ctx.fn(...args);

    // 删除 ctx 上的 fn
    delete ctx.fn;
  
    return result;
};

// ------------------------------ 测试 ------------------------------

const numbers = [5, 6, 2, 3, 7];

// Function.prototype.__apply()
console.log('Function.prototype.__apply()');

const max = Math.max.__apply(null, numbers);
console.log(max); // 7

// Function.prototype.apply()
console.log('Function.prototype.apply()');
const min = Math.min.apply(null, numbers);
console.log(min); // 2
```



## 12 原型 继承 概念



```
1. 继承
例举几种比较常用的继承方式
/**
 * 使用 extends 继承
 */

// 继承类
class Vehicle {}
class Bus extends Vehicle {}

let b = new Bus();
console.log(b instanceof Bus); // true
console.log(b instanceof Vehicle); // true


// 继承普通构造函数
function Person() {}
class Engineer extends Person {}

let e = new Engineer();
console.log(e instanceof Engineer); // true
console.log(e instanceof Person); // true


/**
 * 寄生式组合继承
 */
function Person(name) {
    this.name = name;
}
function Man(name, age) {
    Person.call(this, name, age);
    this.age = age;
}
Man.prototype = Object.create(Person.prototype);
Man.prototype.constructor = Man;

const man = new Man('mxin', 18);
console.log(man instanceof Man); // true
console.log(man instanceof Person); // true
```



## 13、instanceof



```
/**
 * 模拟 instanceof
 * 判断 obj.__proto__ 和 __constructor.prototype 是否相等
 * @param {object} obj 实例对象
 * @param {function} __constructor 构造函数
 */
function __instanceof(obj, __constructor) {
    const prototype = __constructor.prototype;
    obj = Object.getPrototypeOf(obj);

    while (true) {
        if (obj === null) return false;
        if (obj === prototype) return true;
        obj = Object.getPrototypeOf(obj);
    }
}

// ------------------------------ 测试 ------------------------------

function C() {}
function D() {}

const o = new C();

// __instanceof()
console.log('__instanceof()');

console.log(__instanceof(o, C));
console.log(__instanceof(o, D));
console.log(__instanceof(o, Object));

// instanceof
console.log('instanceof');

console.log(o instanceof C);
console.log(o instanceof D);
console.log(o instanceof Object);
```



## 14 object.create



```
/**
 * 模拟 Object.create
 * 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__
 * @param {object} prototype 新创建对象的原型对象，为 null 时 只能使用 Object.create()
 * @param {object} properties 访问器描述符，同 Object.defineProperties 第二个参数
 * @returns {object}
 */
function __create(prototype, properties) {
    if (typeof prototype !== 'object') throw new TypeError('Error');

    function Constructor() {}
    Constructor.prototype = prototype;

    const obj = new Constructor();

    if (prototype) obj.constructor = Constructor;

    // 设置访问器描述符
    if (properties) {
        if (typeof properties !== 'object') throw TypeError('Error');
        Object.defineProperties(obj, properties);
    }

    return obj;
}

// ------------------------------ 测试 ------------------------------

const person = {
    isHuman: false,
    printIntroduction: function () {
        console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
    },
};

// __create()
console.log('__create()');

const __me = __create(person);
__me.name = '__mxin';
__me.isHuman = true;
__me.printIntroduction();

// Object.create()
console.log('Object.create()');

const me = Object.create(person);
me.name = 'mxin';
me.isHuman = true;
me.printIntroduction();

// 目前创建纯净空对象只有 Object.create(null) 可行，无法模拟
const emptyObj = Object.create(null);
console.log(emptyObj);
// {}
//    No properties
```



## 15 Object.is



- 与`==` 运算不同，`==` 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 `"" == false` 判断为 `true`), 而 `Object.is`不会强制转换两边的值
- 与`===` 运算也不相同， `===` 运算符 (也包括 `==` 运算符) 将数字 `-0` 和 `+0` 视为相等 ，而将`Number.NaN` 与 `NaN` 视为不相等

```
/**
 * 模拟 Object.is
 * 判断两个值是否为同一个值
 * 1. 都是 undefined
 * 2. 都是 null
 * 3. 都是 true 或 false
 * 4. 都是相同长度的字符串且相同字符按相同顺序排列
 * 5. 都是相同对象（意味着每个对象有同一个引用）
 * 6. 都是数字且
 *    a. 都是 +0
 *    b. 都是 -0
 *    c. 都是 NaN
 *    d. 或都是非零而且非 NaN 且为同一个值
 * @param {*} x
 * @param {*} y
 */
function __is(x, y) {
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y;
    } else {
        return x !== x && y !== y;
    }
}

// ------------------------------ 测试 ------------------------------

// __is()
console.log('__is()');

console.log(`__is('foo', 'foo'): ${__is('foo', 'foo')}`); // true
console.log(`__is('foo', 'bar'): ${__is('foo', 'bar')}`); // false

const __foo = { a: 1 };
const __bar = { a: 1 };
console.log(`__is(__foo, __foo): ${__is(__foo, __foo)}`); // true
console.log(`__is(__foo, __bar): ${__is(__foo, __bar)}`); // false
console.log(`__is(window, window): ${__is(window, window)}`); // true
console.log(`__is([], []): ${__is([], [])}`); // false
console.log(`__is(null, null): ${__is(null, null)}`); // true

// 特例
console.log(`__is(0, -0): ${__is(0, -0)}`); // false
console.log(`__is(0, +0): ${__is(0, +0)}`); // true
console.log(`__is(-0, -0): ${__is(-0, -0)}`); // true
// console.log(`__is(NaN, 0 / 0): ${__is(NaN, 0 / 0)}`); // true


// Object.is()
console.log('Object.is()');

console.log(`Object.is('foo', 'foo'): ${Object.is('foo', 'foo')}`); // true
console.log(`Object.is('foo', 'bar'): ${Object.is('foo', 'bar')}`); // false

const foo = { a: 1 };
const bar = { a: 1 };
console.log(`Object.is(foo, foo): ${Object.is(foo, foo)}`); // true
console.log(`Object.is(foo, bar): ${Object.is(foo, bar)}`); // false
console.log(`Object.is(window, window): ${Object.is(window, window)}`); // true
console.log(`Object.is([], []): ${Object.is([], [])}`); // false
console.log(`Object.is(null, null): ${Object.is(null, null)}`); // true

// 特例
console.log(`Object.is(0, -0): ${Object.is(0, -0)}`); // false
console.log(`Object.is(0, +0): ${Object.is(0, +0)}`); // true
console.log(`Object.is(-0, -0): ${Object.is(-0, -0)}`); // true
console.log(`Object.is(NaN, 0 / 0): ${Object.is(NaN, 0 / 0)}`); // true
```







## 16 new 

```
/**
 * 模拟 new
 * 1. 创建原型为 constructor.prototype 的新对象 obj
 * 2. 执行构造函数，this 指向 obj
 * 3. 判断构造函数返回值是否为对象，是就返回此对象
 * 4. 构造函数无返回值返回 obj
 * @param {function} constructor
 * @param  {...any} args
 * @returns {object}
 */
function __new(constructor, ...args) {
    if (typeof constructor !== 'function') throw new TypeError('Error');

    // 创建一个空对象，指定原型为constructor.prototype
    const obj = Object.create(constructor.prototype);

    // 执行构造函数，绑定this
    const result = constructor.apply(obj, args);

    // 如果构造函数返回值是一个对象，那么返回该对象， 如果没有就返回 obj
    return result && result instanceof Object ? result : obj;
}

// ------------------------------ 测试 ------------------------------

function Person(name, age) {
    this.name = name;
    this.age = age;
}

// __new
console.log('__new');
const __mxin = __new(Person, '__mxin', 18);
console.log(__mxin);
// Person {name: "__mxin", age: "18"}
//     age: "18"
//     name: "__mxin"
//     __proto__:
//         constructor: ƒ Person(name, age)
//         __proto__: Object

// new
console.log('new');
const mxin = new Person('mxin', 18);
console.log(mxin);
// Person {name: "mxin", age: "18"}
//     age: "18"
//     name: "mxin"
//     __proto__:
//         constructor: ƒ Person(name, age)
//         __proto__: Object
```









## 17 浅拷贝



几种常用方式：

1. 自定义循环
2. 展开运算符
3. [Object.assign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

```
/**
 * 浅拷贝，无脑循环
 * @param {*} targetObj
 */
function shallowClone(targetObj) {
    const resObj = {};
    for (let key in targetObj) {
        resObj[key] = targetObj[key];
    }
    return resObj;
}

// ------------------------------ 测试 ------------------------------

console.log('shallowClone()');

const shallowObj = {
    name: 'mxin',
    age: 18,
};

/**
 * 自定义方法
 */
const a = shallowClone(shallowObj);
a.name = '__mxin';
a.age = 20;

console.log('a', a);
// {name: "__mxin", age: 20}
//   age: 20
//   name: "__mxin"

/**
 * 拓展运算符
 */
const b = { ...a };
b.name = '____mxin';
b.age = 22;

console.log('b', b);
// {name: "____mxin", age: 22}
//   age: 22
//   name: "____mxin"

/**
 * Object.assign()
 */
const c = Object.assign({}, shallowObj)
c.name = '______mxin';
c.age = 24;

console.log('c', c);
// {name: "______mxin", age: 24}
//   age: 24
//   name: "______mxin"

// 不影响原有对象
console.log('shallowObj', shallowObj);
// {name: "mxin", age: 18}
//   age: 18
//   name: "mxin"
```







## 18 深拷贝



```
/**
 * 深拷贝
 * 深层克隆对象结构
 * @param {object} target
 * @returns {object}
 */
function deepClone(target) {
    // 如果不是对象，直接返回本身
    if (!isObject(target) || target === null) return target;

    // 参数类型校验情况还有很多，没有覆盖全面，可以后期拓展
    if (target instanceof Date) return new Date(target);
    if (target instanceof RegExp) return new RegExp(target);

    const obj = {};
    const stack = [
        {
            parent: obj,
            key: null,
            data: target,
        },
    ];

    while (stack.length) {
        const node = stack.pop();
        const parent = node.parent;
        const key = node.key;
        const data = node.data;

        let res = key ? (parent[key] = {}) : parent;

        for (const k in data) {
            if (data.hasOwnProperty(k)) {
                if (isObject(data[k])) {
                    stack.push({
                        parent: res,
                        key: k,
                        data: data[k],
                    });
                } else {
                    res[k] = data[k];
                }
            }
        }
    }

    return obj;
}

/**
 * 判断 target 是否为对象
 * @param {*} target
 */
function isObject(target) {
    return Object.prototype.toString.call(target) === '[object Object]';
}
// ------------------------------ 测试 ------------------------------

console.log('deepClone()');

const deepObj = {
    e: {
        f: {
            g: {
                h: 1,
            },
        },
    },
    i: {
        j: {
            k: {
                l: 2,
            },
        },
    },
};

const d = deepClone(deepObj);
d.e.f.g.h = 2;
d.i.j.k.l = 4;

console.log('d', d);

// 不影响原有对象
console.log('deepObj', deepObj);
```



## 19 对象扁平化



```
/**
 * 对象扁平化
 * 将多层嵌套的 key 合并
 * @param {object} target
 * @param {string} tempKey
 * @param {object} res
 * @returns {object}
 */
function flattenObject(target, tempKey = '', res = {}) {
    // 使用 Object.entries() 将键值对转换成数组，确保 key 与 val 的对应关系
    for (const [key, val] of Object.entries(target)) {
        // 如果 val 是对象，保存合并后的 key 进行递归
        if (isObject(val)) {
            const tmp = tempKey + key + '.';
            flattenObject(val, tmp, res);
        } else {
            // 当 val 不是对象，合并 key 并对结果对象赋值
            const tmp = tempKey + key;
            res[tmp] = val;
        }
    }
    return res;
}

/**
 * 判断 target 是否为对象
 * @param {*} target
 */
function isObject(target) {
    return Object.prototype.toString.call(target) === '[object Object]';
}

// ------------------------------ 测试 ------------------------------

console.log('flattenObject()');

const object = {
    d: {
        e: {
            f: {
                g: {
                    h: 1,
                },
            },
        },
        i: {
            j: {
                k: {
                    l: 2,
                },
            },
        },
    },
};

console.log(flattenObject(object));
// {
//   d.e.f.g.h: 1
//   d.i.j.k.l: 2
// }
```

## 20 数组扁平化



```
 几种常用方式：

递归
Array.prototype.flat()
Array.prototype.reduce()
/**
 * 数组扁平化
 * 判断数组中元素类型，如果是数组类型就递归，否则直接 push 到 res 中
 * @param {array} target
 * @param {array} res
 * @returns {array}
 */
function flattenArray(target, res = []) {
    for (const val of target) {
        if (Array.isArray(val)) {
            flattenArray(val, res);
        } else {
            res.push(val);
        }
    }
    return res;
}

/**
 * 使用 Array.prototype.reduce()
 * @param {array} target
 */
function flattenArrayByReduce(target) {
    const initPre = [];
    return target.reduce(
        (pre, current) =>
            pre.concat(
                Array.isArray(current) ? flattenArrayByReduce(current) : current
            ),
        initPre
    );
}

// ------------------------------ 测试 ------------------------------

console.log('flattenArray()');

const array = [[0], 1, [2, [3, [4, [5, [6]]]]], [7, [8]]];

/**
 * 递归
 */
console.log(flattenArray(array));
// [0, 1, 2, 3, 4, 5, 6, 7, 8]

/**
 * Array.prototype.flat()
 */
console.log(array.flat(Number.MAX_SAFE_INTEGER));
// [0, 1, 2, 3, 4, 5, 6, 7, 8]

/**
 * Array.prototype.reduce()
 */
console.log(flattenArrayByReduce(array));
// [0, 1, 2, 3, 4, 5, 6, 7, 8]
```

## 





## 21 数组去重 



- 使用 `set` 

```
console.log([...new Set(array)]);
```

- 使用对象，或者将对象换成 `map` ，需要注意数组中元素的类型

```
/**
 * 数组去重
 * 基于对象实现，也可以使用 Map
 * @param {array} target
 * @returns {array}
 */
function removeDuplicate(target) {
    const temp = {};
    for (let i = 0; i < target.length; i++) {
        const item = target[i];
        if (
            Object.prototype.toString.call(item) !== '[object Object]' &&
            Object.prototype.toString.call(item) !== '[object Function]' &&
            Object.prototype.toString.call(item) !== '[object Symbol]' &&
            Object.prototype.toString.call(item) !== '[object Array]'
        ) {
            if (temp.hasOwnProperty(item)) {
                target[i] = target[target.length - 1];
                target.length--;
                i--;
            }
        }
        temp[item] = item;
    }
    return target;
}

// ------------------------------ 测试 ------------------------------

console.log('removeDuplicate()');

const array = [
    1,
    1,
    '2',
    '2',
    true,
    true,
    false,
    false,
    undefined,
    undefined,
    null,
    null,
    Symbol('3'),
    Symbol('3'),
    {},
    {},
    [],
    [],
];

console.log(removeDuplicate(array));
```



## 22 promise



- Promise
  - resolve
  - reject
  - then
  - catch
  - finally
- Promise.resolve
- Promise.reject
- Promise.all
- promise.race

```
const isFunction = variable => typeof variable === 'function';

// 定义Promise的三种状态常量
const PENDING = 'pending';
const RESOLVE = 'resolved';
const REJECTED = 'rejected';

class __Promise {
    constructor(fn) {
        this.__status = PENDING;
        // 储存 value，用于 __then 返回
        this.__value = null;
        // 失败队列，在 __then 时注入，resolve 时触发
        this.__rejectedQueues = [];
        // 成功队列，在 __then 时注入，resolve 时触发
        this.__resolvedQueues = [];

        try {
            fn(this.__resolve, this.__reject);
        } catch (err) {
            this.__reject(err);
        }
    }

    __resolve = val => {
        const run = () => {
            if (this.__status !== PENDING) return;
            this.__status = RESOLVE;

            // 依次执行成功队列中的函数，并清空队列
            const runResolved = value => {
                let cb;
                while ((cb = this.__resolvedQueues.shift())) {
                    cb(value);
                }
            };

            // 依次执行失败队列中的函数，并清空队列
            const runRejected = error => {
                let cb;
                while ((cb = this.__rejectedQueues.shift())) {
                    cb(error);
                }
            };

            /*
             * 如果 resolve 的参数为 Promise 对象，
             * 则必须等待该 Promise 对象状态改变后当前 Promsie 的状态才会改变
             * 且状态取决于参数 Promsie 对象的状态
             */
            if (val instanceof __Promise) {
                val.__then(
                    value => {
                        this.__value = value;
                        runResolved(value);
                    },
                    err => {
                        this.__value = err;
                        runRejected(err);
                    }
                );
            } else {
                this.__value = val;
                runResolved(val);
            }
        };

        // 异步调用
        setTimeout(run);
    };

    __reject = err => {
        if (this.__status !== PENDING) return;

        const run = () => {
            this.__status = REJECTED;
            this.__value = err;
            let cb;
            while ((cb = this.__rejectedQueues.shift())) {
                cb(err);
            }
        };

        setTimeout(run);
    };

    __then(onResolved, onRejected) {
        const { __value, __status } = this;

        return new __Promise((onResolvedNext, onRejectedNext) => {
            const resolved = value => {
                try {
                    if (!isFunction(onResolved)) {
                        onResolvedNext(value);
                    } else {
                        const res = onResolved(value);

                        if (res instanceof __Promise) {
                            // 如果当前回调函数返回__Promise对象，必须等待其状态改变后在执行下一个回调
                            res.__then(onResolvedNext, onRejectedNext);
                        } else {
                            // 否则会将返回结果直接作为参数，传入下一个 __then 的回调函数，并立即执行下一个 __then 的回调函数
                            onResolvedNext(res);
                        }
                    }
                } catch (err) {
                    onRejectedNext(err);
                }
            };

            const rejected = error => {
                try {
                    if (!isFunction(onRejected)) {
                        onRejectedNext(error);
                    } else {
                        const res = onRejected(error);

                        if (res instanceof __Promise) {
                            res.__then(onResolvedNext, onRejectedNext);
                        } else {
                            onResolvedNext(res);
                        }
                    }
                } catch (err) {
                    onRejectedNext(err);
                }
            };

            if (__status === PENDING) {
                this.__resolvedQueues.push(resolved);
                this.__rejectedQueues.push(rejected);
            }

            if (__status === RESOLVE) resolved(__value);

            if (__status === REJECTED) rejected(__value);
        });
    }

    __catch(onRejected) {
        return this.__then(null, onRejected);
    }

    __finally(cb) {
        return this.__then(
            value => __Promise.resolve(cb()).__then(() => value),
            reason =>
                __Promise.resolve(cb()).__then(() => {
                    throw new Error(reason);
                })
        );
    }

    static resolve(value) {
        // 如果参数是 __Promise 实例，直接返回这个实例
        if (value instanceof __Promise) return value;
        return new __Promise(resolve => resolve(value));
    }

    static reject(value) {
        return new __Promise((resolve, reject) => reject(value));
    }

    static all(list) {
        return new __Promise((resolve, reject) => {
            const values = [];
            let count = 0;

            for (const [i, p] of list.entries()) {
                // 数组参数如果不是 __Promise 实例，先调用 __Promise.resolve
                this.resolve(p).__then(
                    res => {
                        values[i] = res;
                        count++;
                        // 所有状态都变成 resolved 时返回的 __Promise 状态就变成 resolved
                        if (count === list.length) resolve(values);
                    },
                    err => {
                        // 有一个被 rejected 时返回的 __Promise 状态就变成 rejected
                        reject(err);
                    }
                );
            }
        });
    }

    static race(list) {
        return new __Promise((resolve, reject) => {
            list.forEach(p => {
                this.resolve(p).__then(
                    res => {
                        resolve(res);
                    },
                    err => {
                        reject(err);
                    }
                );
            });
        });
    }
}

// ------------------------------ 测试 ------------------------------

console.log('class __Promise {}');

const p1 = new __Promise((resolve, reject) =>
    setTimeout(() => {
        resolve('mxin');
    }, 500)
);
const p2 = new __Promise((resolve, reject) =>
    setTimeout(() => {
        resolve('__mxin');
    }, 200)
);
const p3 = new __Promise((resolve, reject) => {
    setTimeout(() => {
        reject(new Error('mxin3'));
    }, 100);
});

// 测试 __resolve __then __finally
new __Promise((resolve, reject) => {
    resolve('mxin');
})
    .__then(res => {
        console.log('__resolve:', res);
    })
    .__finally(() => {
        console.log('__resolve finally');
    });

// 测试 __reject __catch __finally
new __Promise((resolve, reject) => {
    reject(new Error());
})
    .__catch(e => {
        console.log('__reject:', e);
    })
    .__finally(() => {
        console.log('__reject finally');
    });

// 测试 static resolve
__Promise
    .resolve('mxin')
    .__then(res => console.log('static resolve:', res))
    .__finally(() => console.log('static resolve finally'));

// 测试 static reject
__Promise
    .reject(new Error())
    .__catch(res => console.log('static reject:', res))
    .__finally(() => console.log('static reject finally'));

// 测试 all，可添加 p3 测试 rejected 状态
__Promise
    .all([p1, p2])
    .__then(res => console.log('all resolve:', res))
    .__catch(e => console.log('all reject', e))
    .__finally(() => console.log('all finally'));

// 测试 race，速度快的优先返回并结束, 添加 p3 优先 reject
__Promise
    .race([p1, p2])
    .__then(res => console.log('race resolve:', res))
    .__catch(e => console.log('race reject', e))
    .__finally(() => console.log('race finally'));
```









## 23 async/await



```
const NEXT = 'next';
const THROW = 'throw';
/**
 * 模拟 async 函数
 * 1.generator 分割代码片段
 * 2.使用一个函数让其自迭代
 * 3.使用 promise 将 yield 包裹起来
 * 4.执行下一步的时机由 promise 来控制
 * @param {*} fn
 */
function __async(fn) {
    return function () {
        // 获取迭代器实例
        const gen = fn.apply(this, arguments);

        return new Promise((resolve, reject) => {
            // 执行下一步
            function _next(value) {
                __step(gen, resolve, reject, _next, _throw, NEXT, value);
            }
            // 抛异常
            function _throw(err) {
                __step(gen, resolve, reject, _next, _throw, THROW, err);
            }
            // 首次触发
            _next(void 0);
        });
    };
}

/**
 * 执行迭代步骤，处理下次迭代结果
 * 1.将所有值promise化
 * 2.当 promise 执行完之后再执行下一步
 * 3.递归调用 next 函数，直到 done == true
 */
function __step(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        return reject(error);
    }
    // 迭代完成
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}

// ------------------------------ 测试 ------------------------------
console.log('async');

__async(function* () {
    const e = yield new Promise(resolve =>
        setTimeout(() => {
            resolve('e');
        }, 1000)
    );
    const a = yield Promise.resolve('a');
    const d = yield 'd';
    const b = yield Promise.resolve('b');
    const c = yield Promise.resolve('c');
    return [a, b, c, d, e];
})().then(
    res => console.log(res) // ['a', 'b', 'c', 'd', 'e']
);
```





## 24 并发



```
/**
 * 异步分片处理并发
 * 1.通过 limitNum 限制并发的 promise 数量
 * 2.临时结果保存到 resArr 中
 * 3.start 返回 promise，全部执行完毕 finally 中 resolve 最终结果
 */
class Limit {
    constructor(limitNum, promiseList) {
        this.resArr = [];
        this.handling = 0;
        this.resolvedNum = 0;
        this.limitNum = limitNum;
        this.promiseList = promiseList;
        this.runTime = this.promiseList.length;
    }

    handle(promise) {
        console.log(promise, this.handling);
        return new Promise((resolve, reject) => {
            promise.then(res => resolve(res)).catch(e => reject(e));
        });
    }

    start() {
        const __this = this;
        return new Promise(resolve => {
            const run = () => {
                if (!__this.promiseList.length) return;
                __this.handling += 1;
                __this
                    .handle(__this.promiseList.shift())
                    .then(res => {
                        __this.resArr.push(res);
                    })
                    .catch(e => {
                        const error = new Error(e);
                        __this.resArr.push(error);
                    })
                    .finally(() => {
                        __this.handling -= 1;
                        __this.resolvedNum += 1;
                        if (__this.resolvedNum === __this.runTime) {
                            resolve(__this.resArr);
                        }
                        run();
                    });
            };

            for (let i = 1; i <= __this.limitNum; i++) {
                run();
            }
        });
    }
}

// ------------------------------ 测试 ------------------------------
console.log('Limit');

const p1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(1);
    }, 1000);
});
const p2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(2);
    }, 1000);
});
const p3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        reject(3);
    }, 2000);
});
const p4 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(4);
    }, 2000);
});
const p5 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(5);
    }, 3000);
});
const p6 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(6);
    }, 3000);
});
const promiseList = [p1, p2, p3, p4, p5, p6];

const limit = new Limit(2, promiseList);

limit.start().then(res => {
    console.log(res);
});
```



##  25 发布/订阅

```
**
 * 事件订阅/发布
 * 1.on 收集 key 对应的回调函数依赖关系，存入 eventList
 * 2.emit 根据第一个参数判断 key 值，并执行其函数依赖
 * 3.remove 根据 key 值清空依赖
 */
class __Event {
    constructor() {
        this.eventList = [];
    }

    on(key, fn) {
        if (!this.eventList[key]) this.eventList[key] = [];
        this.eventList[key].push(fn);
    }

    emit() {
        const key = [].shift.call(arguments);
        const fns = this.eventList[key];

        if (!fns || fns.length === 0) return false;

        for (const fn of fns) {
            fn.apply(this, arguments);
        }
    }

    remove(key) {
        if (!this.eventList[key]) return false;
        this.eventList[key] = null;
        delete this.eventList[key];
    }
}

// ------------------------------ 测试 ------------------------------
// Event
console.log('Event');

const __event = new __Event();

__event.on('name', val => {
    console.log(`info: ${val}`);
    // info: mxin
});

__event.on('name', val => {
    console.log(`info2: ${val}`);
    // info2: mxin
});

// 触发事件，上面两个回调执行对应代码
__event.emit('name', 'mxin');

// 移除事件
__event.remove('name');

// 事件被移除，不再触发
__event.emit('name', 'mxin');
```



## 26 防抖



```
/**
 * 防抖
 * 事件高频触发，间隔 wait 时长执行回调
 * @param {*} fn
 * @param {*} wait
 */
function debounce(fn, wait) {
    let timeout;
    return function () {
        let __this = this,
            args = arguments;
        if (timeout) clearTimeout(timeout);
        timeout = setTimeout(() => {
            fn.apply(__this, args);
        }, wait);
    };
}

// ------------------------------ 测试 ------------------------------

// debounce()
console.log('debounce()');

window.onresize = debounce(function () {
    console.log('改变窗口大小完毕 1000ms 后触执行');
}, 1000);
```





## 27 节流



```
/**
 * 节流
 * 高频事件触发，间隔 delay 时间执行一次回调
 * @param {*} fn
 * @param {*} delay
 */
function throttle(fn, delay) {
    const prevTime = Date.now();
    return function () {
        const curTime = Date.now();
        if (curTime - prevTime > delay) {
            fn.apply(this, arguments);
            prevTime = curTime;
        }
    };
}

// ------------------------------ 测试 ------------------------------

// throttle()
console.log('throttle()');

window.onresize = throttle(function () {
    console.log('间隔 1000ms 执行一次');
}, 1000);
```





## 28 柯里化



```
/**
 * 柯里化
 * 把接受多个参数的函数变换成接受一个单一参数的函数
 * 并返回接受余下的参数且返回结果的新函数
 */
function curry() {
    const args = [...arguments];

    const fn = function () {
        args.push(...arguments);
        return fn;
    };

    fn.toString = () => {
        return args.reduce((pre, current) => pre + current);
    };
    return fn;
}

// ------------------------------ 测试 ------------------------------

// curry
console.log('curry()');

console.log(curry(1)(2)(3)); // 6
console.log(curry(1, 2, 3)(4)); // 10
console.log(curry(1)(2)(3)(4)(5)); // 15
console.log(curry(2, 6)(1)); // 9
```





## 29 vue Reactive



```
具体实现思路及演示可以看之前写过的一篇文章，点击传送

const reactiveMap = new WeakMap();
const targetMap = new WeakMap();
const effectStack = [];

/**
 * 副作用函数
 * @param {*} fn
 */
function effect(fn) {
    try {
        // 将需要执行的effect入栈
        effectStack.push(fn);

        // 执行该effect，进入proxy的get拦截
        return fn();
    } finally {
        // 依赖收集完毕及所有get流程走完，当前effect出栈
        effectStack.pop();
    }
}

/**
 * 依赖收集
 * @param {*} target
 * @param {*} key
 */
function track(target, key) {
    // 初始化依赖Map
    let depsMap = targetMap.get(target);
    if (!depsMap) {
        targetMap.set(target, (depsMap = new Map()));
    }

    // 第二层依赖使用Set存放key对应的effect
    let dep = depsMap.get(key);
    if (!dep) {
        targetMap.get(target).set(key, (dep = new Set()));
    }

    // 取当前栈中的effect存入第二层依赖中
    const activeEffect = effectStack[effectStack.length - 1];
    activeEffect && dep.add(activeEffect);
}

/**
 * 触发响应，执行effect
 * @param {*} target
 * @param {*} key
 */
function trigger(target, key) {
    const depsMap = targetMap.get(target);
    if (depsMap) {
        const effects = depsMap.get(key);
        effects && effects.forEach(run => run());
    }
}

/**
 * 定义响应式对象，返回proxy代理对象
 * @param {*} object
 */
function reactive(object) {
    if (reactiveMap.has(object)) return reactiveMap.get(object);

    const proxy = new Proxy(object, handlers);

    reactiveMap.set(object, proxy);
    return proxy;
}

/**
 * 处理器对象，定义捕获器
 */
const handlers = {
    set(target, key) {
        Reflect.set(...arguments);
        trigger(target, key);
    },
    get(target, key) {
        track(target, key);
        return typeof target[key] === 'object'
            ? reactive(target[key])
            : Reflect.get(...arguments);
    },
};

/**
 * 计算属性
 * @param {*} fn
 */
function computed(fn) {
    return {
        get value() {
            return effect(fn);
        },
    };
}

module.exports = {
    effect,
    reactive,
    computed,
};
```


