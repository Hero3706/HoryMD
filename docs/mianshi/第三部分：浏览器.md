# 第三部分：浏览器


## 1、HTML CSS  JAVASCRIPT 是如何变成页面的？

构建 DOM 树

构建 DOM 树的输入内容是一个非常简单的 HTML 文件，然后经由HTML 解析器解析，最终输出树状结构的 DOM。
 DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。

样式计算（Recalculate Style）

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式

1. 把 CSS 转换为浏览器能够理解的结构
    以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。
2. 转换样式表中的属性值，使其标准化
    CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。2em 被解析成了 32px，red 被解析成了 rgb(255,0,0)，bold 被解析成了 700……
3. 计算出 DOM 树中每个节点的具体样式
    样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。
    CSS 继承就是每个 DOM 节点都包含有父节点的样式。
    层叠是 CSS 的一个基本特征，它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位，CSS 的全称“层叠样式表”正是强调了这一点。

布局阶段

1. 创建布局树
    遍历 DOM 树中的所有可见节点，并把这些节点加到布局中；而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，属性包含 dispaly:none的元素。
2. 布局计算
    计算布局树节点的坐标位置，在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。

分层

因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-indexing做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。
 浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。
 通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。

1. 拥有层叠上下文属性的元素会被提升为单独的一层。明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。
2. 需要剪裁（clip）的地方也会被创建为图层。内容超过容器的尺寸时，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，出现这种裁剪情况的时候，渲染引擎会为文字部分单独创建一个层，如果出现滚动条，滚动条也会被提升为单独的层。

图层绘制

在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制。渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

栅格化（raster）操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。
 合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256或者 512x512。
 然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。
 浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。



 


## 2、chrome  仅仅打开一个页面 为什么有有4个进程？

*** 浏览器进程**。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。

\* **渲染进程**。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。

\* **GPU 进程**。其实，Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的UI界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。

\* **网络进程**。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。

\* 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。

讲到这里，现在你应该就可以回答文章开头提到的问题了：仅仅打开了1个页面，为什么有4个进程？因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU 进程以及1个渲染进程，共4个；如果打开的页面有运行插件的话，还需要再加上1个插件进程。

不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：

*** 更高的资源占用**。因为每个进程都会包含公共基础结构的副本（如JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。

*** 更复杂的体系架构**。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。

对于上面这两个问题，Chrome 团队一直在寻求一种弹性方案，既可以解决资源占用高的问题，也可以解决复杂的体系架构的问题。

**未来面向服务的架构**

为了解决这些问题，在2016年，Chrome官方团队使用“**面向服务的架构**”（Services Oriented Architecture，简称**SOA**）的思想设计了新的 Chrome 架构。也就是说 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而**构建一个更内聚、松耦合、易于维护和扩展的系统**，更好实现 Chrome 简单、稳定、高速、安全的目标。如果你对面向服务的架构感兴趣，你可以去网上搜索下资料，这里就不过多介绍了。

Chrome 最终要把UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，下面是 Chrome“面向服务的架构”的进程模型图：

![img](https://pic3.zhimg.com/80/v2-329658fe821252db47b0964037a1de2a_720w.jpg)

**Chrome“面向服务的架构”进程模型图**

目前 Chrome 正处在老的架构向服务化架构过渡阶段，这将是一个漫长的迭代过程。

Chrome 正在逐步构建 Chrome 基础服务（Chrome Foundation Service），如果你认为Chrome 是“便携式操作系统”，那么 Chrome 基础服务便可以被视为该操作系统的“基础”系统服务层。

同时Chrome还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。

![img](https://pic3.zhimg.com/80/v2-a9ba86d7b03263fa3997d3733d958176_720w.jpg)

**在资源不足的设备上，将服务合并到浏览器进程中**

**总结**

好了，今天就到这里，下面我来简要梳理并总结今天的内容。

本文我主要是从 Chrome 进程架构的视角，分析了浏览器的进化史。

最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，创造性地引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式，这也是 Chrome 团队现阶段的一个主要任务。

鉴于目前架构的复杂性，要完整过渡到面向服务架构，估计还需要好几年时间才能完成。不过Chrome 开发是一个渐进的过程，新的特性会一点点加入进来，这也意味着我们随时能看到Chrome 新的变化。

总体说来，**Chrome 是以一个非常快速的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发，身为开发人员，我们不能坐视不管，而应该紧跟其步伐，收获这波技术红利。**


##  3、强缓存，协商缓存

（一）、强缓存

强缓存主要包括 `expires` 和 `cache-control`。

1、expires

`expires` 是 `HTTP1.0` 中定义的缓存字段。当我们请求一个资源，服务器返回时，可以在 `Response Headers` 中增加 `expires` 字段表示资源的过期时间。



```http
expires: Thu, 03 Jan 2019 11:43:04 GMT
```

它是一个**时间戳**（准确点应该叫格林尼治时间），当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果大于该时间戳则已过期，否则直接使用该缓存资源。

但是，有个大问题，发送请求时是使用的**客户端时间**去对比。一是客户端和服务端时间可能快慢不一致，另一方面是客户端的时间是可以自行修改的（比如浏览器是跟随系统时间的，修改系统时间会影响到），所以不一定满足预期。

2、cache-control

正由于上面说的可能存在的问题，`HTTP1.1` 新增了 `cache-control` 字段来解决该问题，所以当 `cache-control` 和 `expires` 都存在时，`cache-control` 优先级更高。该字段是一个时间长度，单位秒，表示该资源过了多少秒后失效。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它**不依赖客户端时间**。`cache-control` 主要有 `max-age` 和 `s-maxage`、`public` 和 `private`、`no-cache` 和 `no-store` 等值。



```http
cache-control: public, max-age=3600, s-maxage=3600 
```

（1）`max-age` 和 `s-maxage`
 两者是 `cache-control` 的主要字段，它们是一个数字，表示资源过了多少秒之后变为无效。在浏览器中，`max-age` 和 `s-maxage` 都起作用，而且 `s-maxage` 的优先级高于 `max-age`。在代理服务器中，只有 `s-maxage` 起作用。 可以通过设置 `max-age` 为 0 表示立马过期来向服务器请求资源。
 （2）`public` 和 `private`
 `public` 表示该资源可以被所有客户端和代理服务器缓存，而 `private` 表示该资源仅能客户端缓存。默认值是 `private`，当设置了 `s-maxage` 的时候表示允许代理服务器缓存，相当于 `public`。
 （3）`no-cache` 和 `no-store`
 `no-cache` 表示的是不直接询问浏览器缓存情况，而是去向服务器**验证**当前资源是否更新（即协商缓存）。`no-store` 则更狠，完全不使用缓存策略，不缓存请求或响应的任何内容，直接向服务器请求最新。由于两者都不考虑缓存情况而是直接与服务器交互，所以当 `no-cache` 和 `no-store` 存在时会直接忽略 `max-age` 等。

3、pragma

既然讲到了 `no-cache` 和 `no-store`，就顺便把 `pragma` 也讲了。他的值有 `no-cache` 和 `no-store`，表示意思同 `cache-control`，优先级高于 `cache-control` 和 `expires`，即三者同时出现时，先看 `pragma` -> `cache-control` -> `expires`。



```http
pragma: no-cache
```

（二）、协商缓存

上面的 `expires` 和 `cache-control` 都会**访问本地缓存直接验证**看是否过期，如果没过期直接使用本地缓存，并返回 200。但如果设置了 `no-cache` 和 `no-store` 则本地缓存会被忽略，会去**请求服务器验证**资源是否更新，如果没更新才继续使用本地缓存，此时返回的是 304，这就是协商缓存。协商缓存主要包括 `last-modified` 和 `etag`。

1、last-modified

`last-modified` 记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个 `last-modified` 字段，如下：



```http
last-modified: Thu, 20 Dec 2018 11:36:00 GMT
```

当再次请求该资源时，请求头中会带有 `if-modified-since` 字段，值是之前返回的 `last-modified` 的值，如：`if-modified-since:Thu, 20 Dec 2018 11:36:00 GMT`。服务端会对比该字段和资源的最后修改时间，若一致则证明没有被修改，告知浏览器可直接使用缓存并返回 304；若不一致则直接返回修改后的资源，并修改 `last-modified` 为新的值。

但 `last-modified` 有以下两个缺点：

- 只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应，而这正是缓存本来的作用即避免没必要的请求。
- 时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存。

2、etag

为了解决 `last-modified` 上述问题，有了 `etag`。 `etag` 会基于资源的内容编码生成一串唯一的标识字符串，只要内容不同，就会生成不同的 `etag`。启用 `etag` 之后，请求资源后的响应返回会增加一个 `etag` 字段，如下：



```http
etag: "FllOiaIvA1f-ftHGziLgMIMVkVw_"
```

当再次请求该资源时，请求头会带有 `if-none-match` 字段，值是之前返回的 `etag` 值，如：`if-none-match:"FllOiaIvA1f-ftHGziLgMIMVkVw_"`。服务端会根据该资源当前的内容生成对应的标识字符串和该字段进行对比，若一致则代表未改变可直接使用本地缓存并返回 304；若不一致则返回新的资源（状态码200）并修改返回的 `etag` 字段为新的值。

可以看出 `etag` 比 `last-modified` 更加精准地感知了变化，所以 `etag` 优先级也更高。不过从上面也可以看出 `etag` 存在的问题，就是每次生成标识字符串会增加服务器的开销。所以要如何使用 `last-modified` 和 `etag` 还需要根据具体需求进行权衡。






## 4、浏览器内核有啥,咋解决兼容问题

内核名称：使用该内核的浏览器

1. **Trident**:ie/360兼容模式/搜狗
2. **Geoko**:火狐firefox
3. **Presto**:opera(后来改为Webkit又到了Blink内核)
4. **Webkit**:谷歌(Webkit的分支**Blink**) safari 360极速模式(**Blink**)

答题的时候如果记不住单词，可以写出四个类别分别代表的浏览器
ie 火狐 opera 谷歌

二、常见浏览器兼容性问题，原因及解决方法，hack技巧有哪些？

```clike
面对浏览器诸多的兼容性问题，经常需要通过修改CSS样式来调试，其中用的最多的
就是CSS Hack。所谓CSS Hack就是针对不同的浏览器书写不同的CSS样式，通过使
用某个浏览器单独识别的样式代码，控制该浏览器的显示效果。
123
```

答题时写四五个就行了

1. 不同浏览器的标签默认的外补丁（margin）和内补丁（padding）不同

   解决方案：css里增加通配符*{margin：0；padding：0}

2. IE6双边距问题；在IE6中设置了float，同时又设置margin，就会出现边距问题

   解决方案：设置display：inline；

3. 当标签的高度设置小于10px，在IE6、IE7中会超出自己设置的高度

   解决方案：超出高度的标签设置overflow：hidden，或者设置line-height的值小于你的设置高度

4. 图片默认有间距

   解决方案：使用float为img布局

5. IE9以下浏览器不能使用opacity

   解决方案：opacity：0.5；filter：alfha（opacity=50）；filter：progid：


